from socket import socket
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode
from Crypto.Cipher import AES
import json


class RSAEncryption:
    def __init__(self) -> None:
        pass

    # Generate the public and private key pair
    @staticmethod
    def generate_keys(key_prefix: str) -> RSA.RsaKey:
        try:
            private_key = RSA.generate(2048)
            public_key = private_key.publickey()
            private_key_pem = private_key.exportKey().decode()
            public_key_pem = public_key.exportKey().decode()

            with open(f"{key_prefix}_private_key.pem", "w") as priv:
                priv.write(private_key_pem)
            with open(f"{key_prefix}_public_key.pem", "w") as pub:
                pub.write(public_key_pem)

            return public_key
        except Exception as e:
            print(e)


class RSAEncryptionClient(RSAEncryption):
    # initialize the client
    def __init__(self, conn: socket) -> None:
        super().__init__()
        self.pub_key = self.generate_keys(key_prefix="client")
        self.s = conn
        self.secret = None

    # Exchanging the public key with the server
    def exchange_keys(self):
        self.exchange_public_keys()
        self.secret = self.handle_secret()

    def encrypt_message(self, message):
        # Initialize AES object for encryption, parameters: [key], [counter feedback mode]
        cipher = AES.new(self.secret, AES.MODE_CFB)
        # Byte encode it, because AES input must be byte encoded and Encrypt the message
        msgBytes = message.encode()
        encrypted_message = cipher.encrypt(msgBytes)
        # Generate the initialization vector and b64 encode it along with the ciphered text
        iv = b64encode(cipher.iv).decode("utf-8")
        message = b64encode(encrypted_message).decode("utf-8")
        # Create a json formatted message
        return json.dumps({"iv": iv, "ciphertext": message})

    # Receiving the secret key for symmetric encryption
    def handle_secret(self):
        # The secret key coming from the server, and used for encryption and decryption
        secret_key = self.s.recv(1024)
        # Import the client private key to decrypt the secret
        private_key = RSA.importKey(open("client_private_key.pem", "r").read())
        # Using the client private key to decrypt the secret
        cipher = PKCS1_OAEP.new(private_key)
        return cipher.decrypt(secret_key)

    # Send the public key to the server to encrypt the secret
    # The secret is generated by the server and used for symmetric encryption
    def exchange_public_keys(self):
        try:
            print(" Getting public key from the server")
            server_public_key = self.s.recv(1024).decode()
            server_public_key = RSA.importKey(server_public_key)

            print(" Sending public key to server")
            public_pem_key = RSA.importKey(open("client_public_key.pem", "r").read())
            self.s.send(public_pem_key.exportKey())
            print(" Exchange completed!")

        except Exception as e:
            print(" ERROR, you messed up something.... " + e)

    def decrypt_message(self, message):
        # Take out the initialization vector and the ciphered text and b64 decode it
        iv, cipherText = b64decode(message["iv"]), b64decode(message["ciphertext"])
        # Create and AES object, parameters: [secret_key], [counter feedback mode], [initialization vector]
        cipher = AES.new(self.secret, AES.MODE_CFB, iv=iv)
        # Use the object to decrypt the ciphertext
        return cipher.decrypt(cipherText)


class RSAEncryptionServer(RSAEncryption):
    def __init__(self) -> None:
        super().__init__()
        self.pub_key = self.generate_keys(key_prefix="server")
        self.secret_key = get_random_bytes(16)

    # Encrypt the secret with the client public key
    @staticmethod
    def encrypt_secret(client_pub_key, secret_key):
        try:
            cpKey = RSA.importKey(client_pub_key)
            cipher = PKCS1_OAEP.new(cpKey)
            encrypted_secret = cipher.encrypt(secret_key)
            return encrypted_secret
        except Exception as e:
            print(e)

    @staticmethod
    def send_secret(c: socket, secret_key):
        try:
            c.send(secret_key)
            print(" Secret key had been sent to the client ")

        except Exception as e:
            print(e)

    # Exchanging the public key with the client
    @staticmethod
    def send_pub_key(c: socket):
        try:
            public_key = RSA.importKey(open(f"server_public_key.pem", "r").read())
            c.send(public_key.exportKey())
            client_pub_key = c.recv(1024)
            print(f" Client public key had been received")
            return client_pub_key
        except Exception as e:
            print(f"Error exchanging public key with client: {e}")

    def exchange_keys(self, c):
        client_pub_key = self.send_pub_key(c)
        encrypted_secret = self.encrypt_secret(client_pub_key, self.secret_key)
        self.send_secret(c, encrypted_secret)
