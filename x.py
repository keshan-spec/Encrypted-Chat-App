    # Receiving the secret key for symmetric encryption
    def handle_secret(self):
        # The secret key coming from the server, and used for encryption and decryption
        secret_key = self.s.recv(1024)
        # Import the client private key to decrypt the secret
        private_key = RSA.importKey(open("client_private_key.pem", "r").read())
        # Using the client private key to decrypt the secret
        cipher = PKCS1_OAEP.new(private_key)
        return cipher.decrypt(secret_key)

    # Send the public key to the server to encrypt the secret
    # The secret is generated by the server and used for symmetric encryption
    def exchange_public_keys(self):
        try:
            print(" Getting public key from the server")
            server_public_key = self.s.recv(1024).decode()
            server_public_key = RSA.importKey(server_public_key)

            print(" Sending public key to server")
            public_pem_key = RSA.importKey(open("client_public_key.pem", "r").read())
            self.s.send(public_pem_key.exportKey())
            print(" Exchange completed!")

        except Exception as e:
            print(" ERROR, you messed up something.... " + e)

    # Generate public and private key pairs
    def create_key_pairs(self):
        try:
            private_key = RSA.generate(2048)
            public_key = private_key.publickey()
            private_pem = private_key.exportKey().decode()
            public_pem = public_key.exportKey().decode()
            with open(
                "client_private_key.pem", "w"
            ) as priv:  # writing priv key to pem file
                priv.write(private_pem)
            with open(
                "client_public_key.pem", "w"
            ) as pub:  # writing public key to pem file
                pub.write(public_pem)

        except Exception as e:
            print("ERROR, you messed up somethig.... " + e)